---
title: 图像变换操作 —— image transform operation
date: 2017-01-08 18:51:03
tags: 旋转、翻转、裁剪、平移、rotate、fliping、cropping、resize、translate
---

上一节中我们介绍了如何在图像上绘制直线、矩形以及圆，这些都是一些基本的操作，但是基本操作应该还没有完呢！我们前面只是学习了有关于在图像上操刀的一些基本方法，现在我们想直接对图片下手，比如说我们想旋转整个图像或者是裁剪这个图像之类的操作，那么在这篇文章中我们就会有所介绍，一起来看一看吧！

#### 平移图像

对于一张二维图片，我们的平移方向只有x和y两个方向，对于平移后面的数学矩阵运算我自己就不在这里卖弄了，因为我也不熟悉，所以今天我们只需要只要两点就好了，一是我们想要将图像平移到哪儿，而是我们如何使用opencv来完成我们的想法。

opencv中使用放射变换来实现图像的平移，这样有点儿像原本我们有一张图片，然后我们想将这张图片平移一下并显示出来，那么放射变化就像是我们重新定义了一张图片作为底片，然后根据我们需要平移的距离来将原来的图片来放置在底片上，最终我们获得的是这张底片。我也不知道你有没有被我绕晕，有的时候真的是talk is cheap，我们还是来看一下代码吧！

```bash
import cv2
import numpy

imagePath = 'images/girl.jpg'

img = cv2.imread(imagePath, 1)

#
# 定义我们需要平移的矩阵，需要注意的是这个矩阵（数组）的数据类型应该是flaot32
# 我们将定一个将图片向右和向下分别平移40和50像素的矩阵，我们程哲阁矩阵为仿射矩阵
#
translate = numpy.array(
    [
        [1, 0, 40],
        [0, 1, 50]
    ]
).astype(numpy.float32)

#
# 调用warpAffine返回放射变换之后图片
#
translateImage = cv2.warpAffine(img, translate, (img.shape[1], img.shape[0]))

cv2.imshow('beautiful girl', translateImage)
cv2.waitKey(0) & 0XFF
cv2.destroyAllWindows()
```

就如上面的代码显示的内容一样，我们首先定一个仿射矩阵`translate`，然后我们通过`warpAffine`来返回我们需要的图片，下面我来简单介绍一下`warpAffine`这个函数的参数，如下：

+ srcImg 我们需要平移的原图片

+ translate matrix 仿射矩阵

+ shiftImage Shape 返回的仿射变换之后图片的宽高的定义元组

你可能对第三个参数感觉比较奇怪，为什么我们在前面的代码中做`(img.shape[1], img.shape[0])`的定义呢？这是因为我们想让我们得到的仿射图像的尺寸与我们原来的图像尺寸一致，首先解释一下我们想获得某一张图像的尺寸与通道数的信息我们可以通过取这张图片的`shape`属性来获知，如果你想获取的图像是彩色的，那么你会获得三个元素的元组，如果是灰度图像，那么你会只会得到宽与高的值。假设我们得到`(100L,200L,3)`这样的元组，表示我们图像有100个像素点那么高，有200个像素点宽，有三个通道。

个人认为opencv比较蛋疼的地方就是关于这个图像的宽高与平常我们使用的宽高的顺序不一样这一点，这不，我们在`warpAffine`函数中传递进去的第三个参数的尺寸顺序就是`(width, height)`，但是我们通过`shape`属性获取的值却是`(height, width)`，它们现在又不想改过来，我真心觉得这玩意儿有点儿蛋疼，不过最关键的地方在于我们不是opencv的开发者，所以我们还是乖乖地记住它们这么一个怪癖吧！

仿射矩阵解释：
1、如果我们想在x方向对图像进行平移操作，假设我们的平移量为tx，那么我们仿射矩阵的第一个数组就应该为`[1, 0, tx]`，如果你学过有关于计算机图像学的平移操作，那么你很快就会联想到这是什么，如果你没有学过也没有关系，只需要记住我们的这个使用方法就好了。
2、另外如果我们想在y轴对图像进行平移操作，那么我们应该定义仿射矩阵的第二个数组，假设我们平移量为ty，那么我们的第二数组为`[0, 1, ty]`。
3、最终我们将仿射矩阵转变成numpy数组，并将矩阵内的所有的数据都转变成float32类型。

很简单不是吗？我们为了不再多次书写这么多的代码，我们也可以自己封装一些函数来把这些比较复杂的opencv函数封装进去，我相信你是有这个能力的。

下面我们来建立我们自己的函数库，我将其命名为——`imtool.py`，如下，我们的imtool.py的关于图像平移的函数如下：

```bash
import cv2
import numpy

#
# 平移图像
#
def translate( img, tx, ty ):
    matrix = numpy.array([
        [1, 0, tx],
        [0, 1, ty]
    ], dtype=numpy.float32)
    targetImage = cv2.warpAffine(img, matrix, (img.shape[1], img.shape[0]))

    return targetImage
```

#### 总结

本来想在这一篇文章中直接介绍所有的图像变换的函数，不过现在发现自己还是没有预见力，光写一个平移就花了不少的气力，所以我还是重新再建立一个页面吧！

在这篇文章中我们介绍了opencv平移图像的函数，并且我们建立了imtool.py来封装我们自己的代码，将来指不定什么时候我们就不需要知道里面是什么了，只需要知道我怎么调用这些函数以及这些函数是干什么即可。

好了，马上我们将要介绍图像旋转的知识。