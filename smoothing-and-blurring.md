---
title: 平滑与模糊图像——smoothing and blurring
date: 2017-01-12 17:41:03
tags: 平滑、模糊、smoothing、blurring
---

#### 提前回答一下上一节的“新”的问题

我们在上一节的最后一段话中有提到图像噪声，这是个什么东西？就是说图像中出现了不该有的干扰点，那我们就称这些干扰点做噪声。我们知道声音里有噪声，对于强大的人的听觉系统来说，过滤噪音确实非常简单，我们初中的时候学到过“音色”这个概念，这就好比是身份证，我们可以通过音色来辨别该声音是什么，我们在嘈杂的公共场合说话的时候仍然可以听见对方的声音，这就是一个例子。当然，建议人的各种智能系统过于强大，我们只是拿它来举例说明噪声，不小心踩了香蕉皮了。所以重点应该是噪声和过滤噪声这些内容。

如果我们的图像中有一些噪声，那么我们怎么去掉或者是最小化这些噪声的影响呢？答案是让它们与图像融为一体。怎么个意思，这就需要提到我们今天的主角了——平滑与模糊。假如说我们有一张有噪音的图像，我们并不知道这些噪声点的位置（要是知道了就太好办了），我们可以对每一个点都是用临近的一些区域来像素值的平均值来表示，这是一种方法，还有很多的方法，我自己也不甚了解，还是那句话，我们在使用这些函数的时候如果知道背后的算法更好，但是不知道也并没有影响到我们的前进，我现在就属于后者。不过我们还是应该知道我们总的方法是将噪声点与原图像尽量融合一些，这样我们就可以认为图像中没有噪声了，融为一体的方法就是平滑和模糊。

什么是模糊呢？又是一个小儿科的问题，想想你自己在课间休息的时候睡觉了，突然上课铃打响了，你又得开始上课，睁开眼睛那一会儿的世界就是模糊的不是？或者你用手机拍照的时候还没有对焦成功的时候图像是很模糊的，这就是我们所定义的模糊。

什么是平滑呢？是我们要达到模糊效果的一种方法。

暂时先了解到这儿，我们来看一下在opencv中提供了那些方法供我们调用呢？

#### 取平均值（均值滤波）

首先介绍一下模糊的第一种方法——对一个卷积核之内取平均值。首先我们得定义一个卷积核，真不好意思，一个问题还没有解决完，又出现了新的名词。卷积核类似一个小的二维数组，它的宽和高我们定义为奇数个，想象一下，我们的图像上有很多的数组，我们可以有很多的卷积核。所以我们从图像的左上角开始滑动我们的卷积核，先横向然后到最右端再返回最左端，并向下移动，每次移动的距离为一个像素点，不管是向左还是向下（除了向右跳转方向那次），所以我们会得到新的图像，所以我们称这个过程叫平滑，其实就是平滑这个卷积核。最终我们得到的图像会是一个模糊的图像。

如果你仔细一点儿的话，会发现我们通过平滑卷积核之后的图像的尺寸比原图像要小，为什么呢？假如我们有100*100的原图像，现在我们定义一个3×3的卷积核，那么按照我们前面的做法，我们将会得到98×98的图像，这显然不行啊，这样的话我们的图像里面的信息可能就会丢失，这是我们不想看到的，所以还是有人提出了解决方法，提出了一些插值的方法来计算边界上像素点的新像素值，不过具体的算法是什么我还是不是很清楚，但是我敢打赌这个算法实现起来并不会太难。

opencv已经为我们解决了这个问题，我们只需要知道自己需要多大的卷积核（宽和高一定是奇数）即可，来看一下：

```bash
import cv2
import numpy

imagePath = './images/girl.jpg'

img = cv2.imread( imagePath, 1)

#
# 取平均值滤波，取多个卷积核查看效果，hstack是将多个数组沿着水平方向拼接在一起
#
blured = numpy.hstack([
    cv2.blur(img, (3, 3)),
    cv2.blur(img, (5, 5)),
    cv2.blur(img, (7, 7)),
    cv2.blur(img, (11, 11)),
    img
])

cv2.imshow( "all image", blured)
cv2.waitKey(0) & 0XFF
cv2.destroyAllWindows()
```

你会发现我们的卷积核越大，模糊的效果越好。

#### 高斯模糊（高斯滤波）

万变不离其宗，高斯滤波也使用了卷积核的方法，只不过它是一个均值滤波改进版，怎么改进呢？回顾一下，我们在使用均值滤波的时候，就只是简单地认为所有的临近的像素同样是重要的，但这是不合理的，为什么呢？一般的图像具有连贯性，也就是说对于一个像素点，离这个像素点越近的像素的像素值与我们原来的像素点的像素值更相近一些，所以我们可以设计一些权重来实现我们这个想法，如果某一个点离我们的目标点越近，那么这个像素点的权值越高，以此类推。

好了，想法都是有了，怎么来实现这个权重的分配呢？我们总不能提前来定义一个固定的权重的矩阵吧？所以我们看看这个方法的名字——高斯模糊，我们将会使用到高斯分布来解决权值分配的问题。大家都知道，高斯分布函数是一个类似小山峰的函数，所以我们可以通过高斯分布（主要是正态分布）来获得这些权值，如果你想获得更多的信息，我推荐你到百度百科或者维基百科上继续了解，如果想了解原理还是去查几篇吧，祝你好运。

好了，以上就是我们对高斯模糊的一些简单解释，从中我们可以感觉到高斯模糊肯定是比简单的均值平均好一些，那么我们现在来看一下opencv怎么提供这个API的吧！

```bash
gaussianBlur = numpy.hstack([
    cv2.GaussianBlur(img, (3, 3), 0),
    cv2.GaussianBlur(img, (5, 5), 0),
    cv2.GaussianBlur(img, (7, 7), 0),
    cv2.GaussianBlur(img, (11, 11), 0),
    img
])
```

前两个参数与均值滤波的参数一致，现在多了一个参数，第三个参数我们称之为方差——`σ`，与高斯分布有关，它将决定我们取什么样的权重，但是不幸的是我们现在的知识根本不知道如何计算这个权重，所以我们还是让会的人来完成这个事儿吧，所以我们第三个参数传递进去的是0，让opencv自动为我们计算权重，真方便。现在你看一下，这个效果确实比中值滤波的效果要好一些。

#### 中值滤波

中值滤波法是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值（来自百度百科），有了前面两个方法做铺垫，我们现在对中值的理解应该会很轻松了，来直接看效果。

```bash
gaussianBlur = numpy.hstack([
    cv2.medianBlur(img, 3),
    cv2.medianBlur(img, 5),
    cv2.medianBlur(img, 7),
    cv2.medianBlur(img, 11),
    img
])
```

我尝试了一下，发现这个方法的滤波效果太过了，搞得我的图像失真很严重，但是失真严重说明噪声与图像的融合程度却是越好的，真是奇怪，虽然这就是我们想要的结果，但是现在我倒有点儿不太喜欢这个方法了，因为我不喜欢马赛克！！！不过话又说回来了，人家的效果确实杠杠的，受用了。

#### 双边滤波

这个方法原理好难，我个人认为我在这里是讲解不清楚了，我在这里推荐两篇博文给大家阅读吧！个人认为很不错，不错的地方就是我需要看好久！！！[博文1](http://blog.csdn.net/bugrunner/article/details/7170471)[博文2](http://blog.csdn.net/dangchangying/article/details/14451963)，不过这个方法的作用还是很明了的，就是我们上面三种滤波方法都有一个特点，那就是会将图像的边缘的信息模糊掉，这对我们来说可不是一件好事，所以我们希望既保留边缘信息，又消掉噪声，真是一个天大的好事，不过确实不是梦，来看一下在opencv中是怎样实现的。

```bash
gaussianBlur = numpy.hstack([
    cv2.bilateralFilter(img, 5, 21, 21),
    cv2.bilateralFilter(img, 7, 31, 31),
    cv2.bilateralFilter(img, 9, 41, 41),
    img
])
```

这个函数的参数还是挺奇怪的，不过你会发现第二个参数都是奇数，啊！！明白了吗？我们前面的卷积核都是奇数。另外最后两个参数是两个sigma参数，在双边滤波之中我们使用到了两个高斯函数，所以需要两个sigma，但是我现在还不知道这两个sigma如何取值会对我们的结果比较友好，所以又回到了我们前面提到的——我们需要的是尝试，而不是经验！

#### 总结

这一篇我们讲的东西比较多，其中我们还简要介绍了一些模糊算法，不过你对此不了解也不会影响到你熟练运用opencv的模糊函数。另外千万别问哪一个方法是最好的，这个问题很那回答，还得你自己去寻找答案。

好了，下一节我们将会学习关于图像二值化的方法。