---
title: 图像中物体边缘检测与图像梯度——edge detection
date: 2017-01-12 22:01:42
tags: 图像中物体的边沿、图像的梯度、gradient、edge detection
---

#### 梯度介绍

学过高数的人都应该知道梯度这个概念，我相信你的老师在跟你们讲解梯度的时候都会举一个例子——我们可以通过梯度计算来寻找上山或者下山最快的道路。我当时听得很楞，这么牛！！！但是后来我想了一想，如果山上有陡峭的悬崖，那么通过梯度计算就一定会得到一条通过悬崖的路线，这样的路你敢走吗？开个玩笑，我们来看一下梯度指的是什么。

在一个函数中，某一个点的梯度表示这个函数值增长最快的方向，假如我们的函数是二维的，那没什么好说的，梯度就是导数，如果我们的函数的三维的（函数图像），那么我们的函数可能就像行星表面一样，有凹有凸，这个时候使用我们最初的定义是最好的——梯度表示在某个点函数值增长最快的方向。

但是我们的图像的离散的像素点组成的，所以我们不能生硬地把数学上的梯度的概念搬过来，现在我们来定义一下图像的梯度——相邻的像素点的像素值变化的快慢。与数学上的定义类似，但又不完全相同。我们想一下，平常的时候我们经常会说这个世界还有诗和远方。如果你往远处望去，在地平线与天空的交界处会有明显的分界线，那么我们是怎么分辨出这是个分界线的呢？是因为在分界线的两侧的光线的明暗变化很大，也就是我们前面定义的梯度变化很大，所以我们一般认为在图像中像素值变化较大的区域有可能就存在一些边界。

#### opencv中提取边界线



首先来看一下拉普拉斯算子来提取边缘，什么是算子呢？嗯！！！说实话，我解一下相关的数学题还是可以的，但是现在让我解释确实有一些捉襟见肘，我对它的理解还不是很深入，所以在这里我还是向你推荐一篇博文吧，它里面讲解得很清楚，也比较好懂。[拉普拉拉斯算子博文](http://www.cnblogs.com/xfzhang/archive/2011/01/19/1939020.html)。也许你对其中背后的算法不是很感兴趣，没关系，我们来看一下如何在opencv中调用相关的函数的。

```bash
import cv2
import numpy

imagePath = './images/girl.jpg'

img = cv2.imread(imagePath, 0)

lap = cv2.Laplacian(img.copy(), cv2.CV_64F)
lap = numpy.absolute(lap).astype(numpy.uint8)

allImage = numpy.hstack([
    img, lap
])

cv2.imshow( "all image", allImage)
cv2.waitKey(0) & 0XFF
cv2.destroyAllWindows()
```

我们在调用Laplacian函数的时候，传递了两个参数，第一个是需要提取边缘的原图像，第二个是输出的图像的数据类型，你可以打印一下lap的dtype的值，得到的是float64类型，为什么需要这个类型呢？我猜啊应该是计算梯度的时候需要用到浮点数，而且还需要一些精度，所以对数据的类型的格式要求比较高，不过我们记住这么个写法不就挺好的，以后也不用思考这是为什么了（倒不是我鼓励大家不求甚解的学习态度，我鼓励各位专研某一个问题，但是有的时候我们需要分配我们的精力与时间，对于某些事情我们就别太专注了，事倍功半）。

调用Laplacian函数得到的图像是梯度的图像，也就是说在这张图片中的每一个点都是通过Laplacian函数计算之后的梯度值，因为梯度有正有负，而我们的opencv中的图像是从0到255的值，又因为我们只需要图像中的梯度的大小的信息，而不需要符号的信息，所以我们在Laplacian之后直接使用取绝对值的方式，最后是转换数据类型（opencv只能显示uint8类型的图像）。

#### Sobel算子

这个玩意儿跟拉普拉斯有点儿类似（个人感觉），如果愿意研究其背后的原理，那么我将向你推荐一篇博文[Sobel 算子博文](http://blog.csdn.net/goodshot/article/details/10170073)，好了，只了解来看在opencv中如何使用它来提取物体的边缘信息。

```bash
import cv2
import numpy

imagePath = './images/girl.jpg'

img = cv2.imread(imagePath, 0)

sobelX = cv2.Sobel(img.copy(), cv2.CV_64F, 1, 0)
sobelY = cv2.Sobel(img.copy(), cv2.CV_64F, 0, 1)

sobelX = numpy.absolute( sobelX ).astype(numpy.uint8)
sobelY = numpy.absolute( sobelY ).astype(numpy.uint8)

allImage = numpy.hstack([
    sobelX, sobelY, img, cv2.bitwise_or(sobelY, sobelX)
])

cv2.imshow( "all image", allImage)
cv2.waitKey(0) & 0XFF
cv2.destroyAllWindows()
```

在上面的代码中，我们分别计算了图像的x方向的梯度以及y方向的梯度，最后使用位运算将两者结合成最终的梯度图像。Sobel函数的参数前两个与Laplacian相同，只是后面两个参数有些奇怪，不过我相信你应该看出其中的奥秘了，我们计算x方向梯度的时候传递的是`1,0`，计算y方向的时候传递的时候`0, 1`，况且对于二维图像来说，我们最多只会对两个方向计算梯度，所以我现在问你，我么需要计算x，y方向的梯度应该怎么做呢？


#### Canny边缘检测

在这里我们将会学习到一种新的边缘检测的方法，其实它并不新，它是通过一些So本来算子以及一些阈值二值化等方式的结合得到我们最终的物体的边缘，来看一下opencv中是怎样调用它的吧！

```bash
allImage = numpy.hstack([
    img, cv2.Canny(img.copy(), 50, 150)
])
```

调用真的挺简单的，我们来解释一下Canny函数的参数：

+ img 需要检测边缘的图像

+ threshold1 第一个阈值，如果图像中的像素点的像素值低于这个阈值的话，那么就被认为是边缘

+ threshold2 第二个阈值，如果图像中的像素点的像素值大于该阈值的话，那么也会被认为是边缘

就是这么轻松，还有一些其他的参数是可选的，并且我个人认为暂时我还使用不到它们，所以我们也不介绍这些可选的参数了。

你也许就会有疑惑，这个Canny算法好像也没有什么牛气的地方啊，在图像中低于第一个阈值和大于第二个阈值的像素点都被认为是边缘，那么我们自己也可以很轻松来实现这个方法，的确是这样的，但是这个函数最关键的地方在于它会帮我们评估那些像素值在threshold1到threshhold2之间的像素点是否是边缘，具体的算法我就不太了解了，不过既然这个算法被人们承认，那么它必有闪亮之处，我们千万不要低估了这个方法。

#### 总结

图像总物体的边缘检测的大体思路就是判断某一个区域的图像梯度的大小，那么我们获取图像中的物体边沿用来干嘛呢？既然是计算机视觉，我们当然希望计算机能够理解某一个物体是什么了，所以我们能得到物体的边缘，那么我们将这个物体提取出来也不远了！

下一节我们将学习有关物体轮廓的提取。